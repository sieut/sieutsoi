<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: ; style-src 'unsafe-inline'; script-src 'self';">
        <style>body { padding: 0 40px; }</style>
    </head>
    <body>
        <h1>Gumroad Code Challenge</h1>
        <h2>Frontend Challenge</h2>
        <script src="/gumroad.js"></script>
        <p>
        Here's an anchor link that is modified by the script to show an inline popup when clicked: <a class="gumroad-button" href="https://gumroad.com/l/demo" target="_blank">Buy my product</a> and you can download the script <a href="/gumroad.js" download>here</a>.
        </p>
        <p>
        I didn't have time to support the advanced features, except for preload page on hover because that one interests me the most. On page load, the script would inject an empty and invisible iframe. It then gets all anchor tags and check if it's a link to a Gumroad product (gumroad.com/l/product_id). Each of the product links is injected with event listener for onhover and onclick to preload and show the iframe respectively.
        </p>
        <p>
        Here's a few other links to show that multiple links in a page would work even though I inject only 1 iframe: <a class="gumroad-button" href="https://gumroad.com/l/ungatebundle" target="_blank">Ungate Bundle</a>    <a class="gumroad-button" href="https://gumroad.com/l/pCEOL" target="_blank">Strum</a>
        </p>

        <h2>System Design Challenge</h2>
        <p>Schema:</p>
        <img src="/schema.png"/>
        <h3>Users</h3>
        <ul>
            <li>payout_lag is how often the user wants to be paid</li>
            <li>next_payout_timestamp is the next time user will be paid</li>
        </ul>
        <h3>Transactions</h3>
        <ul>
            <li>transaction_type is an enum that has Buy, Refund and Payout as options</li>
            <li>amount is monetary value of the transaction, or the delta to the balance</li>
            <li>post_tx_balance is the balance of user1 after transaction has completed</li>
            <li>time is the time of transaction</li>
            <li>user1 is the user whose balance is changed because of the transaction</li>
        </ul>
        <h3>Indices</h3>
        <ul>
            <li>BTree index on (user1_id, time) for Transactions</li>
            <li>BTree index on (next_payout_timestamp) for Users</li>
        </ul>
        <h3>Keeping Track and Updating Balance</h3>
        <p>Balance is kept track in the Transactions table. Whenever a new transaction is created, we would get the last transaction of user1, which has user1's current balance, to calculate post_tx_balance. Note that we would need to hold the lock on the last transaction to avoid race conditions. The index on (user1_id, time) will help improve performance of fetching the last transaction. </p>
        <p>Users' balance could be kept in the Users table, and the field could be updated when creating a new transaction. But that would result in a lot of updates to Users table, which could affect other parts of the product.</p>
        <h3>Payouts</h3>
        <p>To execute the payouts, we would need background jobs to look for users who are due for a payout. With the index on next_payout_timestamp, scanning for rows that have next_payout_timestamp > now should be fast. And executing the payout is just creating a transaction, after that, the job will update next_payout_timestamp according to payout_lag.</p>
        <p>When users change their preferences for payout_lag, we have to update next_payout_timestamp accordingly.</p>
    </body>
</html>
